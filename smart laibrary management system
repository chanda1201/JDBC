 import time
import serial
import argparse
import serial.tools.list_ports
import requests
import socket 
import threading
ports = serial.tools.list_ports.comports()
for port, desc, hwid in sorted(ports):
#print("{}: {} [{}]".format(port, desc, hwid))
print("{}: {}".format(port, desc))
ap = argparse.ArgumentParser()
ap.add_argument("-p", "--port", required=True,
help = "com port of arduino")
args = vars(ap.parse_args())
port = args['port']
port = port 
baud = 9600
serialPort = serial.Serial(port, baud, timeout=1)
# open the serial port
if serialPort.isOpen():
[24/01, 12:56 pm] Chanda: print(serialPort.name + ' is open...')
server_end = False
def serverThread(serialPort):
# next create a socket object
s = socket.socket() 
print ("Socket successfully created")
port = 8001 
# Next bind to the port
# we have not typed any ip in the ip field
# instead we have inputted an empty string
# this makes the server listen to requests
# coming from other computers on the network
s.bind(('', port)) 
print ("socket binded to %s" %(port))
# put the socket into listening mode
s.listen(5) 
print ("socket is listening") 
global server_end
# a forever loop until we interrupt it or
# an error occurs
while not server_end:
[24/01, 12:57 pm] Chanda: # Establish connection with client.
c, addr = s.accept() 
print ('Got connection from', addr )
readStr = c.recv(50).strip().decode('utf-8')
if readStr._contains_("open="):
cmd = readStr.split("open=")[1].split(" ")[0]
print('cmd: ',cmd)
if cmd == "ONE":
serialPort.write(("OPEN_ONE\n").encode('utf-8'))
if cmd == "TWO":
serialPort.write(("OPEN_TWO\n").encode('utf-8'))
if readStr._contains_("close="):
serialPort.write(("CLOSE\n").encode('utf-8'))
print(readStr)
c.send('Thank you for connecting'.encode())
c.close()
x = threading.Thread(target=serverThread, args=(serialPort,)) 
x.start()
while True:
oprationStatus = str(serialPort.readline())
print(oprationStatus)
if oprationStatus._contains_('<rfidtagid>') and 
oprationStatus._contains_('</rfidtagid>'):
[24/01, 12:57 pm] Chanda: dataStrTagId = oprationStatus.split('<rfidtagid>')[1]
dataStrTagId = dataStrTagId.split('</rfidtagid>')[0]
print("TAG Id is : "+dataStrTagId)
rfID = dataStrTagId #'8987778'
url = "http://127.0.0.1:8000/scanedid/"+rfID+"/"
request_result = requests.get(url)
print(request_result)
if request_result.text._contains_("USER_ACCOUNT"):
#serialPort.write(("open\n").encode('utf-8'))
print("Open")
elif request_result.text._contains_("BOOK_ID"):
print("BOOK_ID") 
else:
print('unknown')
[24/01, 12:57 pm] Chanda: from django.contrib import admin
from .models import RFID, Book, UserAccount, IssuedBook
admin.site.register(RFID)
admin.site.register(Book)
admin.site.register(UserAccount)
admin.site.register(IssuedBook)
[24/01, 12:57 pm] Chanda: rom django.apps import AppConfig
class LibraryConfig(AppConfig):
default_auto_field = 'django.db.models.BigAutoField'
name = 'library'
[24/01, 12:58 pm] Chanda: om django.db import models
from django.contrib.auth.models import User
from django.db.models.deletion import CASCADE, SET_NULL
# Create your models here.
class RFID(models.Model):
CARD_TYPE = [
('US','User'),
('BO','Book'),
]
id = models.AutoField(primary_key=True)
[24/01, 12:58 pm] Chanda: rfid = models.CharField(max_length=100,blank=False, null=False,unique=True)
rfidtype = models.CharField(max_length=2,blank=False, null=False, 
choices=CARD_TYPE)
isrfid = models.BooleanField(default=True, blank=False, null=False, editable=False)
def _str_(self) -> str:
return str(self.rfidtype)+": "+str(self.rfid)
class Book(models.Model):
SHELFS = [
('ONE','Shelf One'),
('TWO','Shelf Two'),
]
id = models.AutoField(primary_key=True)
name = models.CharField(max_length=100,blank=False, null=False)
subject = models.CharField(max_length=100,blank=False, null=False)
author = models.CharField(max_length=100,blank=False, null=False)
publishdate = models.CharField(max_length=100,blank=False, null=False)
rfid = models.OneToOneField(RFID,on_delete=CASCADE, unique=True)
isbook = models.BooleanField(default=True, blank=False, null=False, editable=False)
shelf = models.CharField(max_length=20,choices=SHELFS, null=True, blank=True)
def _str_(self) -> str:
return str(self.name)
class UserAccount(models.Model):
id = models.AutoField(primary_key=True)
user = models.OneToOneField(User,on_delete=CASCADE)
rollno = models.CharField(max_length=100,blank=False, null=False)
batch_and_class = models.CharField(max_length=100,blank=False, null=False)
rfid = models.OneToOneField(RFID,on_delete=CASCADE, unique=True)
[24/01, 12:58 pm] Chanda: isuseraccount = models.BooleanField(default=True, blank=False, 
null=False, editable=False)
def _str_(self) -> str:
return str(self.user.username)
class IssuedBook(models.Model):
id = models.AutoField(primary_key=True)
useraccount = models.ForeignKey(UserAccount,on_delete=CASCADE)
book = models.ForeignKey(Book,on_delete=CASCADE)
issuedon = models.DateTimeField(auto_now=True)
returned = models.BooleanField(default=False, blank=False, null=False)
returenedon = models.DateTimeField(auto_now_add=True)
isissuedbook = models.BooleanField(default=True, blank=False, null=False, 
editable=False)
def _str_(self) -> str:
if self.returned:
return "(returend): "+str(self.book.name)+ " | " + 
str(self.useraccount.user.username) + " | Issued On:" + str(self.issuedon) + "| Returend 
on:" +str(self.returenedon)
else:
return "(issued): "+ str(self.book.name)+ " | " + 
str(self.useraccount.user.username) + " | Issued On:" + str(self.issuedon)
[24/01, 12:58 pm] Chanda: from rest_framework import serializers
from django.contrib.auth.models import User
from . models import RFID, Book, UserAccount, IssuedBook
class SerializerRFID(serializers.ModelSerializer):
class Meta:
model = RFID
fields = '_all_'
class SerializerBook(serializers.ModelSerializer):
rfid = SerializerRFID(many=False)
class Meta:
model = Book
fields = '_all_'
class SerializerUser(serializers.ModelSerializer):
class Meta:
model = User
fields = ['username',]
class SerializerUserAccount(serializers.ModelSerializer):
user = SerializerUser(many=False)
rfid = SerializerRFID(many=False)
class Meta:
model = UserAccount
fields = '_all_' 
class SerializerIssuedBook(serializers.ModelSerializer):
book = SerializerBook(many=False)
useraccount = SerializerUserAccount(many=False)
[24/01, 12:59 pm] Chanda: class Meta:
model = IssuedBook
[24/01, 12:59 pm] Chanda: from django.urls import path
from . import views
urlpatterns = [
path('',views.mainpage,name='mainpage'),
path('scanedid/<str:rfid>/',views.processRFID,name='mainpage'),
path('issuebook/<str:rfid>/<str:useracid>/',views.issueBook,name='issuebook'),
path('returnbook/<str:rfid>/<str:useracid>/',views.returnBook,name='returnbook'),
path('search/<str:search>/',views.searchBook,name='search'),
path('openshelf/<str:shelf>/',views.openShelf,name='openshelf'),
[24/01, 12:59 pm] Chanda: from django.shortcuts import render, HttpResponse
from django.http import JsonResponse
# Create your views here.
import channels_redis
#from outside of consumer
from channels.layers import get_channel_layer
from asgiref.sync import async_to_sync
import requests
import pandas as
[24/01, 12:59 pm] Chanda: from library.models import RFID, Book, IssuedBook, UserAccount
def mainpage(request):
room_name = 'live'
url = "http://127.0.0.1:8001?close=ALL"
try:
request_result = requests.get(url)
print(request_result)
except:
print('Socket error!')
useracs = UserAccount.objects.all()
for userac in useracs:
file_name = ""+userac.user.username+ "_data.csv"
datalogs = pd.DataFrame([], columns=['Name', 'Subject', 'Author','Publish 
Date','Issued on','Shelf', 'Returend', 'Returened on' ])
datalogs.to_csv(file_name, index=False)
issuedBooks = IssuedBook.objects.filter(useraccount=userac).all()
old_data = pd.read_csv(file_name)
for isbook in issuedBooks:
name = isbook.book.name
sub = isbook.book.subject
auth = isbook.book.author
pub = isbook.book.publishdate
rf = isbook.book.rfid
shelf = isbook.book.shelf
retu = isbook.returned
issue = isbook.issuedon
[24/01, 1:00 pm] Chanda: retuon = isbook.returenedon
new_data = pd.DataFrame([[name, sub, auth, pub, issue, shelf, retu, retuon]], 
columns=['Name', 'Subject', 'Author','Publish Date','Issued on','Shelf', 'Returend', 
'Returened on' ])
updated = pd.concat([old_data, new_data])
old_data = updated
#print(issuedBooks)
old_data.to_csv(file_name, index=False)
print(useracs)
books = Book.objects.all()
file_name = "all_books_data.csv"
datalogs = pd.DataFrame([], columns=['Name', 'Subject', 'Author','Publish Date','Shelf' ])
datalogs.to_csv(file_name, index=False)
old_data = pd.read_csv(file_name)
for book in books:
name = book.name
sub = book.subject
auth =book.author
pub = book.publishdate
rf = book.rfid
shelf = book.shelf
new_data = pd.DataFrame([[name, sub, auth, pub, shelf]], columns=['Name', 
'Subject', 'Author','Publish Date','Shelf' ])
updated = pd.concat([old_data, new_data])
old_data = updated
[24/01, 1:00 pm] Chanda: old_data.to_csv(file_name, index=False)
return render(request, 'main.html' ,{'room_name': room_name})
# todo create chat app with fixed chat groupname
# create templates of page 
# show them on browser
from .serializer import SerializerBook, SerializerIssuedBook, SerializerUserAccount
def processRFID(request,rfid):
# get rf id -> get type then if user get user
# if user get useraccount send it to ws
# get issued books list sent on token 
rfidobj = RFID.objects.filter(rfid=rfid).first()
if rfidobj :
if rfidobj.rfidtype == 'US':
useraccount = UserAccount.objects.filter(rfid=rfidobj).first()
serializer = SerializerUserAccount(useraccount,many=False)
channel_layer = get_channel_layer()
print(channel_layer)
async_to_sync(channel_layer.group_send)("chat_live", {"type": "chat_message", 
"message": serializer.data })
issuedBooks = IssuedBook.objects.filter(useraccount=useraccount).all()
serializer = SerializerIssuedBook(issuedBooks,many=True)
[24/01, 1:00 pm] Chanda: channel_layer = get_channel_layer()
print(channel_layer)
async_to_sync(channel_layer.group_send)("chat_live", {"type": "chat_message", 
"message": serializer.data })
return HttpResponse('USER_ACCOUNT')
elif rfidobj.rfidtype == 'BO':
book = Book.objects.filter(rfid=rfidobj).first()
serializer = SerializerBook(book, many=False)
channel_layer = get_channel_layer()
print(channel_layer)
async_to_sync(channel_layer.group_send)("chat_live", {"type": "chat_message", 
"message": serializer.data })
return HttpResponse('BOOK_ID')
return HttpResponse('UNKNOWN_ID')
def issueBook(request,rfid,useracid):
rfidobj = RFID.objects.filter(rfid=rfid).first()
if rfidobj.rfidtype == 'BO':
book = Book.objects.filter(rfid=rfidobj).first()
useraccount = UserAccount.objects.filter(id=useracid).first()
[24/01, 1:01 pm] Chanda: alreadyIssued = 
IssuedBook.objects.filter(book=book).filter(useraccount=useraccount).filter(returned=Fals
e).first()
#useraccount 
if alreadyIssued is None:
issuedbook = IssuedBook.objects.create(book=book, 
useraccount=useraccount).save()
else:
issuedbook = alreadyIssued
issuedBooks = IssuedBook.objects.filter(useraccount=useraccount).all()
serializer = SerializerIssuedBook(issuedBooks,many=True)
channel_layer = get_channel_layer()
print(channel_layer)
async_to_sync(channel_layer.group_send)("chat_live", {"type": "chat_message", 
"message": serializer.data })
return HttpResponse('ISSUED')
return HttpResponse('Unknown id')
def returnBook(request,rfid, useracid):
rfidobj = RFID.objects.filter(rfid=rfid).first()
if rfidobj.rfidtype == 'BO':
book = Book.objects.filter(rfid=rfidobj).first()
useraccount = UserAccount.objects.filter(id=useracid).first()
[24/01, 1:01 pm] Chanda: #useraccount 
IssuedBook.objects.filter(book=book).filter(useraccount=useraccount).update(returne
d=True)
issuedBooks = IssuedBook.objects.filter(useraccount=useraccount).all()
serializer = SerializerIssuedBook(issuedBooks,many=True)
channel_layer = get_channel_layer()
print(channel_layer)
async_to_sync(channel_layer.group_send)("chat_live", {"type": "chat_message", 
"message": serializer.data })
return HttpResponse('Returened')
return HttpResponse('Unknown id')
def searchBook(request, search):
rfids = RFID.objects.filter(rfidtype='BO').all()
books = Book.objects.filter(rfid__in=rfids).all()
books = books.filter(name__contains = search ).all()
serializer = SerializerBook(books, many=True)
return JsonResponse(safe=False, data = serializer.data)
def openShelf(request,shelf):
url = "http://127.0.0.1:8001?open="+shelf
try:
request_result = requests.get(url)
[24/01, 1:02 pm] Chanda: print(request_result)
except:
print('Socket error!')
return JsonResponse(safe=False, data='{"open":"success", "shelf":"' +shelf+ '"}')

# don't import any costly modules
import sys
import os
is_pypy = '_pypy_' in sys.builtin_module_names
def warn_distutils_present():
if 'distutils' not in sys.modules:
return
if is_pypy and sys.version_info < (3, 7):
# PyPy for 3.6 unconditionally imports distutils, so bypass the warning
# https://foss.heptapod.net/pypy/pypy/-
/blob/be829135bc0d758997b3566062999ee8b23872b4/lib-python/3/site.py#L250
return
import warnings
warnings.warn(
"Distutils was imported before Setuptools, but importing Setuptools "
"also replaces the `distutils` module in `sys.modules`. This may lead "
"to undesirable behaviors or errors. To avoid these issues, avoid "
"using distutils directly, ensure that setuptools is installed in the "
"traditional way (e.g. not an editable install), and/or make sure "
"that setuptools is always imported before distutils.")
[24/01, 1:02 pm] Chanda: def clear_distutils():
if 'distutils' not in sys.modules:
return
import warnings
warnings.warn("Setuptools is replacing distutils.")
mods = [
name for name in sys.modules
if name == "distutils" or name.startswith("distutils.")
]
for name in mods:
del sys.modules[name]
def enabled():
"""
Allow selection of distutils by environment variable.
"""
which = os.environ.get('SETUPTOOLS_USE_DISTUTILS', 'local')
return which == 'local'
def ensure_local_distutils():
import importlib
clear_distutils()
# With the DistutilsMetaFinder in place,
# perform an import to cause distutils to be
# loaded from setuptools._distutils. Ref #2906.
with shim():
importlib.import_module('distutils')
# check that submodules load as expected
core = importlib.import_module('distutils.core')
assert 'distutils' in core.file, core.file_
[24/01, 1:02 pm] Chanda: assert 'setuptools._distutils.log' not in sys.modules
def do_override():
"""
Ensure that the local copy of distutils is preferred over stdlib.
See https://github.com/pypa/setuptools/issues/417#issuecomment-392298401
for more motivation.
"""
if enabled():
warn_distutils_present()
ensure_local_distutils()
class _TrivialRe:
def _init_(self, *patterns):
self._patterns = patterns
def match(self, string):
return all(pat in string for pat in self._patterns)
class DistutilsMetaFinder:
def find_spec(self, fullname, path, target=None):
if path is not None:
return
method_name = 'spec_for_{fullname}'.format(**locals())
method = getattr(self, method_name, lambda: None)
return method()
def spec_for_distutils(self):
if self.is_cpython():
[24/01, 1:03 pm] Chanda: return
import importlib
import importlib.abc
import importlib.util
try:
mod = importlib.import_module('setuptools._distutils')
except Exception:
# There are a couple of cases where setuptools._distutils
# may not be present:
# - An older Setuptools without a local distutils is
# taking precedence. Ref #2957.
# - Path manipulation during sitecustomize removes
# setuptools from the path but only after the hook
# has been loaded. Ref #2980.
# In either case, fall back to stdlib behavior.
return
class DistutilsLoader(importlib.abc.Loader):
def create_module(self, spec):
mod._name_ = 'distutils'
return mod
def exec_module(self, module):
pass
return importlib.util.spec_from_loader(
'distutils', DistutilsLoader(), origin=mod._file_
)
@staticmethod
[24/01, 1:03 pm] Chanda: def is_cpython():
"""
Suppress supplying distutils for CPython (build and tests).
Ref #2965 and #3007.
"""
return os.path.isfile('pybuilddir.txt')
def spec_for_pip(self):
"""
Ensure stdlib distutils when running under pip.
See pypa/pip#8761 for rationale.
"""
if self.pip_imported_during_build():
return
clear_distutils()
self.spec_for_distutils = lambda: None
@classmethod
def pip_imported_during_build(cls):
"""
Detect if pip is being imported in a build script. Ref #2355.
"""
import traceback
return any(
cls.frame_file_is_setup(frame)
for frame, line in traceback.walk_stack(None)
)
@staticmethod
def frame_file_is_setup(frame):
"""
Return True if the indicated frame suggests a setup.py file.
[24/01, 1:03 pm] Chanda: # some frames may not have _file_ (#2940)
return frame.f_globals.get('_file_', '').endswith('setup.py')
DISTUTILS_FINDER = DistutilsMetaFinder()
def add_shim():
DISTUTILS_FINDER in sys.meta_path or insert_shim()
class shim:
def _enter_(self):
insert_shim()
def _exit_(self, exc, value, tb):
remove_shim()
def insert_shim():
sys.meta_path.insert(0, DISTUTILS_FINDER)
def remove_shim():
try:
sys.meta_path.remove(DISTUTILS_FINDER)
except ValueError
